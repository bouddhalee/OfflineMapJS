<!DOCTYPE html>
<!-- saved from url=(0112)https://mdn.mozillademos.org/en-US/docs/IndexedDB/Using_IndexedDB$samples/Full_IndexedDB_example?revision=536717 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />
    <style>
        #map { height: 720px; }
    </style>
    <script type="text/javascript" src="./IndexedDBShim.min.js"></script>
    <script type="text/javascript" src="./idbstore.min.js"></script>
    <script>
        CM_URL = 'http://{s}.tile.cloudmade.com/d4fc77ea4a63471cab2423e66626cbb6/997/256/{z}/{x}/{y}.png';

        mapquestUrl = 'http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png'
        subDomains = ['otile1','otile2','otile3','otile4']
        mapquestAttrib = 'Data, imagery and map information provided by <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>, <a href="http://www.openstreetmap.org/" target="_blank">OpenStreetMap</a> and contributors.'
    </script>
</head>
<body>
    <div id="map"></div>

    <script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js"></script>
    <script>
        var ajax = function (src, responseType, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', src, true);
            xhr.responseType = responseType || 'text';
            xhr.onload = function(err) {
                if (this.status == 200) {
                    callback(this.response);
                }
            };
            xhr.send();
        };

        var maxNbCachedZoomLevels = 5;
        var images;

        images = new IDBStore({
            dbVersion: 6,
            storeName: 'image',
            keyPath: 'id',
            autoIncrement: true,
            onStoreReady: function(){
                storeReady();
            },
            indexes: [
                { name: 'index', unique: true }
            ]
        });

        MyLayer = L.TileLayer.extend({
            _imageToDataUri: function (image) {
                var canvas = window.document.createElement('canvas');
                canvas.width = image.naturalWidth || image.width;
                canvas.height = image.naturalHeight || image.height;

                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);

                return canvas.toDataURL('image/png');
            },

            _tileOnLoadWithCache: function () {
                var newData = {
                    "index": this._storageKey,
                    "image": this._layer._imageToDataUri(this)
                };
                images.put(newData);
                L.TileLayer.prototype._tileOnLoad.apply(this, arguments);
            },

            _setUpTile: function (tile, key, value, cache) {
                if (cache) {
                    tile._storageKey = key;
                    tile.onload = this._tileOnLoadWithCache;
                    tile.crossOrigin = 'Anonymous';
                } else {
                    tile.onload = this._tileOnLoad;
                }
                tile.src = value;
                this.fire('tileloadstart', {
                    tile: tile,
                    url: tile.src
                });
            },

            _loadTile: function (tile, tilePoint) {
                tile._layer = this;
                tile.onerror = this._tileOnError;
                this._adjustTilePoint(tilePoint);
                var key = tilePoint.x + ", " + tilePoint.y + ", " + tilePoint.z;

                var myKeyRange = images.makeKeyRange({
                    only: key
                });

                var self = this;

                var onItem = function(items){
                    if(items.length > 0){
                        if(items.length > 1){
                            console.log("duplicates...")
                        }
                        else{
                            console.log("found");
                            self._setUpTile(tile, key, items[0].image, false);
                        }
                    }
                    else{
                        console.log("not found");
                        //self._setUpTile(tile, key, self.getTileUrl(tilePoint), true);
                        self._setUpTile(tile, key, self.getTileUrl(tilePoint), false);
                    }
                }

                var onError = function() {
                    console.log("error");
                    //this._setUpTile(tile, key, this.getTileUrl(tilePoint), true);
                    this._setUpTile(tile, key, this.getTileUrl(tilePoint), false);
                }

                images.query(onItem,
                    {
                        index: 'index',
                        keyRange: myKeyRange,
                        filterDuplicates: false,
                        onError: onError
                });
            }
        });

        var myLayer = new MyLayer(mapquestUrl, {maxZoom: 18, attribution: mapquestAttrib, subdomains: subDomains});
        var map;

        function storeReady(){
            map = L.map('map').setView([51.505, -0.09], 13);

            myLayer.addTo(map);
            map.addControl(new MyControl());
        }

        var MyControl = L.Control.extend({
            options: {
                position: 'topright'
            },

            onAdd: function (map) {
                var newButton = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);

                var image = L.DomUtil.create('img', 'leaflet-buttons-control-img', newButton);
                image.setAttribute('src', "cacheBtn.png");

                L.DomEvent.addListener(newButton, 'click', this.onClick, this);
                L.DomEvent.disableClickPropagation(newButton);
                return newButton;
            },

            onClick: function (){
                var startingZoom = myLayer._getZoomForUrl();
                var maxZoom = map.getMaxZoom();
                console.log("actualZoom: " + startingZoom);

                var nbZoomLevelsToCache = maxZoom - startingZoom;
                if(nbZoomLevelsToCache > maxNbCachedZoomLevels){
                    alert("Not possible to save more than " + maxNbCachedZoomLevels + " zoom levels.")
                }

                for(var tile in myLayer._tiles){
                    var split = tile.split(":");
                    var x = parseInt(split[0]);
                    var y = parseInt(split[1]);
                    this.split(x, y, startingZoom, maxZoom);
                }
            },

            split: function(x, y, currentZ, finalZ){
                this.getImage(x, y, currentZ);

                if(currentZ < finalZ){
                    this.split(x * 2, y * 2, currentZ + 1, finalZ);
                    this.split(x * 2 + 1, y * 2, currentZ + 1, finalZ);
                    this.split(x * 2, y * 2 + 1, currentZ + 1, finalZ);
                    this.split(x * 2 + 1, y * 2 + 1, currentZ + 1, finalZ);
                }
            },

            getImage: function(x, y, currentZ){
                var index = Math.abs(x + y) % myLayer.options.subdomains.length;
                var subdomain = myLayer.options.subdomains[index];
                var url = L.Util.template(mapquestUrl, L.extend({
                    s: subdomain,
                    z: currentZ,
                    x: x,
                    y: y
                }, myLayer.options));

                var key = x + ", " + y + ", " + currentZ;
                ajax(url, 'arraybuffer', function (response) {
                    images.put({"index": key, "image": arrayBufferToBase64ImagePNG(response)});
                    console.log("added image with key: " + key);
                });
            }
        });

        function arrayBufferToBase64ImagePNG(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            for (var i = 0, l = bytes.byteLength; i < l; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return 'data:image/png;base64,' + btoa(binary);
        }


    </script>
</body>
</html>