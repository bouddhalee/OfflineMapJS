<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="./leaflet.css" />
    <style>
        #map { height: 720px; }
    </style>
    <!-- https://www.npmjs.org/package/queue-async -->
    <script type="text/javascript" src="./leaflet.js"></script>
    <script type="text/javascript" src="./queue.v1.min.js"></script>
    <script type="text/javascript" src="./IndexedDBShim.min.js"></script>
    <script type="text/javascript" src="./idbstore.min.js"></script>
    <script>
        mapquestUrl = 'http://{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png'
        subDomains = ['otile1','otile2','otile3','otile4']
        mapquestAttrib = 'Data, imagery and map information provided by <a href="http://open.mapquest.co.uk" target="_blank">MapQuest</a>, <a href="http://www.openstreetmap.org/" target="_blank">OpenStreetMap</a> and contributors.'
    </script>
</head>
<body>
    <div id="map"></div>
    <script>
        // TAKEN FROM OfflineMap
        var ajax = function (src, responseType, callback, error, queueCallback) {
            if(hasBeenCanceled){
                queueCallback();
                return;
            }

            var xhr = new XMLHttpRequest();
            xhr.open('GET', src, true);
            xhr.responseType = responseType || 'text';
            xhr.onload = function(err) {
                if (this.status == 200) {
                    callback(this.response);
                }
                else{
                    error();
                }
                queueCallback();
            };
            xhr.send();
        };

        var maxNbCachedZoomLevels = 5;
        var cacheLoadedImages = false;
        var nbImagesLeftToSave = 0;
        var nbImagesWithError = 0;

        var images = new IDBStore({
            dbVersion: 8,
            storeName: 'image',
            keyPath: null,
            autoIncrement: false,
            onStoreReady: function(){
                storeReady();
            }
        });

        MyLayer = L.TileLayer.extend({
            // TAKEN FROM OfflineMap
            _imageToDataUri: function (image) {
                var canvas = window.document.createElement('canvas');
                canvas.width = image.naturalWidth || image.width;
                canvas.height = image.naturalHeight || image.height;

                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);

                return canvas.toDataURL('image/png');
            },

            // TAKEN FROM OfflineMap
            _tileOnLoadWithCache: function () {
                images.put(this._storageKey, {"image": this._layer._imageToDataUri(this)});
                L.TileLayer.prototype._tileOnLoad.apply(this, arguments);
            },

            // TAKEN FROM OfflineMap
            _setUpTile: function (tile, key, value, cache) {
                if (cache) {
                    tile._storageKey = key;
                    tile.onload = this._tileOnLoadWithCache;
                    tile.crossOrigin = 'Anonymous';
                } else {
                    tile.onload = this._tileOnLoad;
                }
                tile.src = value;
                this.fire('tileloadstart', {
                    tile: tile,
                    url: tile.src
                });
            },

            _loadTile: function (tile, tilePoint) {
                tile._layer = this;
                tile.onerror = this._tileOnError;
                this._adjustTilePoint(tilePoint);

                var self = this;
                var onSuccess = function(item){
                    if(item){
                        console.log("found");
                        self._setUpTile(tile, key, item.image, false);
                    }
                    else{
                        console.log("not found");
                        self._setUpTile(tile, key, self.getTileUrl(tilePoint), cacheLoadedImages);
                    }
                }

                var onError = function() {
                    console.log("error");
                    this._setUpTile(tile, key, this.getTileUrl(tilePoint), cacheLoadedImages);
                }

                var key = tilePoint.x + ", " + tilePoint.y + ", " + tilePoint.z;
                images.get(key, onSuccess, onError);
            }
        });

        var myLayer = new MyLayer(mapquestUrl, {maxZoom: 18, attribution: mapquestAttrib, subdomains: subDomains});
        var map;
        var controls;

        function storeReady(){
            //images.deleteDatabase();
            map = L.map('map').setView([-2.9, -79], 13);

            myLayer.addTo(map);

            controls = new MyControl();
            map.addControl(controls);
        }

        var hasBeenCanceled = false;
        var MyControl = L.Control.extend({
            options: {
                position: 'topright'
            },

            onAdd: function (map) {
                var controls = L.DomUtil.create('div', 'leaflet-buttons-control-button', this._container);

                var cacheButton = L.DomUtil.create('img', 'cache-button', controls);
                cacheButton.setAttribute('src', "cacheBtn.png");

                this._counter = L.DomUtil.create('div', 'counter', controls);
                this._counter.innerHTML = "0";

                this._errorCounter = L.DomUtil.create('div', 'error-counter', controls);
                this._errorCounter.innerHTML = "0";

                var cancelButton = L.DomUtil.create('img', 'cancel-button', controls);
                cancelButton.setAttribute('src', "cancelBtn.png");

                L.DomEvent.addListener(cacheButton, 'click', this.onCacheClick, this);
                L.DomEvent.disableClickPropagation(cacheButton);

                L.DomEvent.addListener(cancelButton, 'click', this.onCancelClick, this);
                L.DomEvent.disableClickPropagation(cancelButton);

                return controls;
            },

            onCacheClick: function (){
                hasBeenCanceled = false;
                saveImages();
            },

            onCancelClick: function (){
                hasBeenCanceled = true;
            }
        });

        // TAKEN FROM OfflineMap
        /*
         Probably btoa can work incorrect, you can override btoa with next example:
         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding#Solution_.232_.E2.80.93_rewriting_atob%28%29_and_btoa%28%29_using_TypedArrays_and_UTF-8
         */
        function arrayBufferToBase64ImagePNG(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            for (var i = 0, l = bytes.byteLength; i < l; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return 'data:image/png;base64,' + btoa(binary);
        }

        function createKey(x, y, z){
            return x + ", " + y + ", " + z;
        }

        var myQueue;
        var imagesToQuery;
        var imagesToQueryArray;

        function saveImages(){
            var startingZoom = myLayer._getZoomForUrl();
            var maxZoom = map.getMaxZoom();
            var minZoom = 2;
            console.log("actualZoom: " + startingZoom);

            var nbZoomLevelsToCache = maxZoom - startingZoom;
            if(nbZoomLevelsToCache > maxNbCachedZoomLevels){
                alert("Not possible to save more than " + maxNbCachedZoomLevels + " zoom levels.")
            }

            if(myQueue){
                alert("system is busy.")
                return;
            }

            imagesToQuery = {};

            for(var tile in myLayer._tiles){
                var split = tile.split(":");
                var x = parseInt(split[0]);
                var y = parseInt(split[1]);
                getZoomedInImages(x, y, startingZoom, maxZoom);
                getZoomedOutImages(Math.floor(x/2), Math.floor(y/2), startingZoom - 1, minZoom);
            }

            imagesToQueryArray = [];
            for(var key in imagesToQuery){
                imagesToQueryArray.push(key);
            }

            images.getBatch(imagesToQueryArray, startLoadingImages, onImageError, 'dense');
        }

        function startLoadingImages(items){
            myQueue = queue(8);
            var i = 0;
            items.forEach(function (item){
                if(item){
                    // image already exist
                }
                else{
                    var key = imagesToQueryArray[i];
                    var data = imagesToQuery[key];

                    nbImagesLeftToSave++;
                    controls._counter.innerHTML = nbImagesLeftToSave;

                    console.log("will defer for key " + key);
                    myQueue.defer(ajax, createURL(data.x, data.y, data.z), 'arraybuffer', function (response) {
                                images.put(key, {"image": arrayBufferToBase64ImagePNG(response)});
                                console.log("added image with key: " + key);
                                nbImagesLeftToSave--;
                                controls._counter.innerHTML = nbImagesLeftToSave;
                            },
                            function (){
                                nbImagesWithError++;
                                controls._errorCounter.innerHTML = nbImagesWithError;
                                nbImagesLeftToSave--;
                                controls._counter.innerHTML = nbImagesLeftToSave;
                            });
                }

                i++;
            });

            console.log("will wait for all");
            myQueue.awaitAll(function(error, data) {
                myQueue = null;
                console.log("done waiting");
                nbImagesLeftToSave = 0;
                controls._counter.innerHTML = nbImagesLeftToSave;
            });
        }

        function getZoomedInImages(x, y, currentZ, maxZ){
            getImage(x, y, currentZ);

            if(currentZ < maxZ){
                getZoomedInImages(x * 2, y * 2, currentZ + 1, maxZ);
                getZoomedInImages(x * 2 + 1, y * 2, currentZ + 1, maxZ);
                getZoomedInImages(x * 2, y * 2 + 1, currentZ + 1, maxZ);
                getZoomedInImages(x * 2 + 1, y * 2 + 1, currentZ + 1, maxZ);
            }
        }

        function getZoomedOutImages(x, y, currentZ, finalZ){
            getImage(x, y, currentZ);
            if(currentZ > finalZ){
                //console.log("zoomed out image: " + x + ", " + y + ", " + currentZ)
                getZoomedOutImages(Math.floor(x / 2), Math.floor(y / 2), currentZ - 1, finalZ);
            }
        }

        function getImage(x, y, z){
            var key = createKey(x, y, z);
            if(!imagesToQuery[key]){
                imagesToQuery[key] = {key:key, x: x, y: y, z: z};
            }
        }

        function onImageError(){
            // What should be done?
            console.log("Image error");
        }

        function createURL(x, y, z){
            var subdomainIndex = Math.abs(x + y) % myLayer.options.subdomains.length;
            var subdomain = myLayer.options.subdomains[subdomainIndex];
            return L.Util.template(mapquestUrl,
                    L.extend({
                        s: subdomain,
                        z: z,
                        x: x,
                        y: y
                    }, myLayer.options));
        }
    </script>
</body>
</html>